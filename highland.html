<!DOCTYPE html>
<html>
    <head>
    <style type="text/css" >
    body {
        margin: 0;
        background-color: white;
    }
    canvas {
        display: block;  /* prevents scrollbar */
        width: 100vw;
        height: 100vh;
     }
     #container {
         position: relative;
     }
     #container canvas, .overlay {
         position: absolute;
     }
     canvas {
         border: 1px solid black;
     }

     .slider-container {
        background: white;
        border: 3px solid #000;
        width: 300px;
        padding: 5px;
        border-radius: 10px;

        position: fixed;
        bottom: 10px;
        right: 10px;

        display: grid;
        grid-template-columns: 20% 25% 55%;
        grid-gap: 0px;
    }

    .box {
        background-color: #444;
        color: #fff;
        font-family: Arial, Helvetica, sans-serif;
    }

     .overlay {
         z-index: 10;
         opacity: 90%;
     }

    </style>
    </head>
    <body>


        <!-- https://stackoverflow.com/questions/13870677/resize-viewport-canvas-according-to-browser-window-size -->
        <!-- https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html -->

        <div id="container">
            <canvas id="gl_canvas"></canvas>
            <div class="control-panel overlay">
                <div class="note">blah blah</div>
                <div class="slider-container">
                    <div class="box"><label for="slider1" class="label1">order:</label></div>
                    <div class="box"><span class="overlay label left-label label1" id="label1"></span></div>
                    <div class="box"><input type="range" min="3.0" max="20.0" value="7.0" class="overlay slider" id="slider1"><br /></div>

                    <div class="box"><label for="slider2" class="label2">speed:</label></div>
                    <div class="box"><span class="overlay label left-label label2" id="label2"></span></div>
                    <div class="box"><input type="range" min="-2.0" max="2.0" value="0.1" step="0.1" class="overlay slider" id="slider2"><br /></div>

                    <div class="box"><label for="slider3" class="label3">width:</label></div>
                    <div class="box"><span class="overlay label left-label label3" id="label3"></span></div>
                    <div class="box"><input type="range" min="0.5" max="3.0" value="1.0" step="0.5" class="overlay slider" id="slider3"><br /></div>

                    <div class="box"><label for="slider4" class="label4">color:</label></div>
                    <div class="box"><span class="overlay label left-label label4" id="label4"></span></div>
                    <div class="box"><input type="range" min="1" max="6" value="0" step="1" class="overlay slider" id="slider4"><br /></div>
                </div>
            </div>

        <script id="vertex-shader" type="glsl">
         attribute vec2 coord;
         void main() {
             gl_Position = vec4(coord, 0, 1);
         }
        </script>

        <script id="fragment-shader" type="glsl">
         #ifdef GL_FRAGMENT_PRECISION_HIGH
	       precision highp float;
         #else
           precision mediump float;
         #endif

         float PI = 3.14159265359;
         uniform float millisecs;
         uniform float W;
         uniform float H;
         uniform float mx;
         uniform float my;
         uniform float v1;
         uniform float v2;
         uniform float v3;

         float fmod(float x, float y) {
             return (x - y * floor(x / y));
         }

         float wrap(float x) {
             return abs(fmod(x+1.0,2.0)-1.0);
         }

         float line_segment(in vec2 p, in vec2 a, in vec2 b) {
            vec2 ba = b - a;
            vec2 pa = p - a;
            float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
            return length(pa - h * ba);
        }

        float arc(in vec2 p, in float a0, in float a1, in float r ) {
            float a = mod(atan(p.y, p.x), radians(360.));
        
            float ap = a - a0;
            if (ap < 0.)
                ap += radians(360.);
            float a1p = a1 - a0;
            if (a1p < 0.)
                a1p += radians(360.);
        
            // is a outside [a0, a1]?
            // https://math.stackexchange.com/questions/1044905/simple-angle-between-two-angles-of-circle
            if (ap >= a1p) {
                    // clamp angle to [a0, a1] by finding the closer one of the two
                    // https://gamedev.stackexchange.com/questions/4467/comparing-angles-and-working-out-the-difference
                    float da0 = abs(abs(a0 - a) - radians(180.)); 
                    float da1 = abs(abs(a1 - a) - radians(180.)); 
                    if (da0 > da1)
                        a = a0;
                    else
                        a = a1;
            }
        
            vec2 q = vec2(r * cos(a), r * sin(a));
            return length(q - p); 
        }
        
        float hue2rgb(float f1, float f2, float hue) {
            if (hue < 0.0)
                hue += 1.0;
            else if (hue > 1.0)
                hue -= 1.0;
            float res;
            if ((6.0 * hue) < 1.0)
                res = f1 + (f2 - f1) * 6.0 * hue;
            else if ((2.0 * hue) < 1.0)
                res = f2;
            else if ((3.0 * hue) < 2.0)
                res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;
            else
                res = f1;
            return res;
        }
        
        vec3 hsl2rgb(vec3 hsl) {
            vec3 rgb;
            
            if (hsl.y == 0.0) {
                rgb = vec3(hsl.z); // Luminance
            } else {
                float f2;
                
                if (hsl.z < 0.5)
                    f2 = hsl.z * (1.0 + hsl.y);
                else
                    f2 = hsl.z + hsl.y - hsl.y * hsl.z;
                    
                float f1 = 2.0 * hsl.z - f2;
                
                rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));
                rgb.g = hue2rgb(f1, f2, hsl.x);
                rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));
            }   
            return rgb;
        }
        
        vec3 hsl2rgb(float h, float s, float l) {
            // https://github.com/Jam3/glsl-hsl2rgb/blob/master/index.glsl
            return hsl2rgb(vec3(h, s, l));
        }

        float sdf_text(float t, vec2 pos) {
            // manual text example
            // TODO: array of structs instead
            float d = 1000.0;
            // H
            d = min(d, line_segment(pos, vec2(0, 0), vec2(0, 2)));
            d = min(d, line_segment(pos, vec2(1, 0), vec2(1, 2)));
            d = min(d, line_segment(pos, vec2(0, 1), vec2(1, 1)));
            // I
            d = min(d, line_segment(pos, vec2(2, 0), vec2(2, 2)));
            // G
            d = min(d, line_segment(pos, vec2(3, .5), vec2(3, 1.5)));
            d = min(d, line_segment(pos, vec2(4, .5), vec2(4, 1)));
            d = min(d, line_segment(pos, vec2(3.5, 1), vec2(4, 1)));
            d = min(d, arc(pos-vec2(3.5, 1.5), 0.0, PI, 0.5));
            d = min(d, arc(pos-vec2(3.5, .5), PI, 2.0*PI, 0.5));
            // H
            d = min(d, line_segment(pos, vec2(5, 0), vec2(5, 2)));
            d = min(d, line_segment(pos, vec2(6, 0), vec2(6, 2)));
            d = min(d, line_segment(pos, vec2(5, 1), vec2(6, 1)));
            // L
            d = min(d, line_segment(pos, vec2(7, 0), vec2(7, 2)));
            d = min(d, line_segment(pos, vec2(7, 0), vec2(8, 0)));
            // A
            d = min(d, line_segment(pos, vec2(9, 0), vec2(9, 1.5)));
            d = min(d, line_segment(pos, vec2(9, 1), vec2(10, 1)));
            d = min(d, line_segment(pos, vec2(10, 1.5), vec2(10, 0)));
            d = min(d, arc(pos-vec2(9.5, 1.5), 0.0, PI, 0.5));
            // N
            d = min(d, line_segment(pos, vec2(11, 0), vec2(11, 1.5)));
            d = min(d, line_segment(pos, vec2(12, 0), vec2(12, 1.5)));
            d = min(d, arc(pos-vec2(11.5, 1.5), 0.0, PI, 0.5));
            // D
            d = min(d, line_segment(pos, vec2(13, 0), vec2(13, 2)));
            d = min(d, line_segment(pos, vec2(13, 0), vec2(13.5, 0)));
            d = min(d, line_segment(pos, vec2(13, 2), vec2(13.5, 2)));
            d = min(d, line_segment(pos, vec2(14, .5), vec2(14, 1.5)));
            d = min(d, arc(pos-vec2(13.5, 1.5), 0.0, 0.5*PI, 0.5));
            d = min(d, arc(pos-vec2(13.5, 0.5), 1.5*PI, 2.0*PI, 0.5));

            return d;
        }

        vec4 color1(float t, float d, float v1, float v2, float v3) {
            // continuous gradient color
            /*
            z = d;                    // distance from SDF scene
            z = z/width               // size of colorbands
            z = z - t*speed           // bands emanate out (or in) from letterforms
            z = wrap(z)               // bidirectional wrap in [0, 1] - ugly, dont do it
            z = floor(order*z)/order  // quantize to get bands
            z = fmod(z, 1.0)          // unidirectional wrap in [0, 1]
            */
            float order = v1;
            float speed = v2;
            float width = v3;
            float zz = floor(order*(d/width-t*speed))/order;
            vec3 rgb = hsl2rgb(fmod(zz, 1.0), 1.0, 0.5);
            return vec4(rgb, 1.0);
        }

        vec4 color2(float d) {
            // simple color
            float z = wrap(5.0 * d / 1.0);  // z -> sawtooth in [0, 1]
            return vec4(1.0-z, 1.0-z, z, 1);
        }

        vec4 color3(float d) {
            // Inigo Quilez color
            vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);
            col *= 1.0 - exp(-2.0*abs(d));
            col *= 0.8 + 0.2*cos(140.0*d);
            col = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );
            return vec4(col,1.0);
        }

        void main() {
            vec2 res = vec2(W, H);
            vec2 pos = (gl_FragCoord.xy - res.xy * .5) / min(res.x, res.y);
            float zoom = 20.0;
            pos *= zoom;
            pos += vec2(7, .7);
            float t = 1.0 * millisecs / 1000.0;

            float d = sdf_text(t, pos);
            gl_FragColor = color1(t, d, v1, v2, v3);
            // gl_FragColor = color2(d);
        }

        </script>


        <script type="text/javascript">

         canvas = document.getElementById("gl_canvas");
         gl = canvas.getContext("webgl");
         gl.canvas.width  = window.innerWidth;
         gl.canvas.height = window.innerHeight;

         // webgl boilerplate
         gl.viewport(0,0,canvas.width, canvas.height);
         const vertShader = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader, document.getElementById('vertex-shader').innerText);
         gl.compileShader(vertShader);
         const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader, document.getElementById('fragment-shader').innerText);
         gl.compileShader(fragShader);
         if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
             console.error(gl.getShaderInfoLog(fragShader));
         }
         const prog = gl.createProgram();
         gl.attachShader(prog, vertShader);
         gl.attachShader(prog, fragShader);
         gl.linkProgram(prog);
         gl.useProgram(prog);
         const vertBuf = gl.createBuffer();
         gl.bindBuffer(gl.ARRAY_BUFFER, vertBuf);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,1,  -1,-1,  1,-1, 1,1]), gl.STATIC_DRAW);
         const coordPtr = gl.getAttribLocation(prog, 'coord');
         gl.vertexAttribPointer(coordPtr, 2, gl.FLOAT, false, 0, 0);
         gl.enableVertexAttribArray(coordPtr);
         gl.clearColor(1,0,0,1);

         // setup uniform variables
         const millisecsPtr = gl.getUniformLocation(prog, 'millisecs');
         const canvasWidthPtr = gl.getUniformLocation(prog, 'W');
         const canvasHeightPtr = gl.getUniformLocation(prog, 'H');
         const mouseXPtr = gl.getUniformLocation(prog, 'mx');
         const mouseYPtr = gl.getUniformLocation(prog, 'my');
         const v1Ptr = gl.getUniformLocation(prog, 'v1');
         const v2Ptr = gl.getUniformLocation(prog, 'v2');
         const v3Ptr = gl.getUniformLocation(prog, 'v3');
         const v4Ptr = gl.getUniformLocation(prog, 'v4');
         const start = new Date().getTime();

         mouseX = window.innerWidth/2
         mouseY = window.innerHeight/2

         function render() {
             console.log("render start");

             var w = canvas.clientWidth;
             var h = canvas.clientHeight;

             gl.viewport(0, 0, w, h);

             v4_labels = {
                1: "primary",
                2: "simple",
                3: "IQ",
                4: "70s",
                5: "gengrad1",
                6: "6",
             }
             // shader stuff
             var v1 = document.getElementById("slider1").value
             document.getElementById("label1").innerHTML = v1;
             var v2 = document.getElementById("slider2").value
             document.getElementById("label2").innerHTML = v2;
             var v3 = document.getElementById("slider3").value
             document.getElementById("label3").innerHTML = v3;
             var v4 = document.getElementById("slider4").value
             document.getElementById("label4").innerHTML = v4_labels[v4];

             gl.uniform1f(millisecsPtr, (new Date().getTime())-start);
             gl.uniform1f(v1Ptr, v1);
             gl.uniform1f(v2Ptr, v2);
             gl.uniform1f(v3Ptr, v3);
             gl.uniform1f(v4Ptr, v4);
             gl.uniform1f(canvasWidthPtr, w);
             gl.uniform1f(canvasHeightPtr, h);
             gl.uniform1f(mouseXPtr, mouseX);
             gl.uniform1f(mouseYPtr, mouseY);
             gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
             requestAnimationFrame(render);
         };

         function resizeCanvas() {

             var width = canvas.clientWidth;
             var height = canvas.clientHeight;
             console.log("resizeCanvas start "  +width+" "+height)
             if (canvas.width != width ||
                 canvas.height != height) {
                 canvas.width = width;
                 canvas.height = height;

                 // in this case just render when the window is resized.
                 render();
             }
         }

         function movePointer(e) {
             mouseX = e.clientX
             mouseY = e.clientY
         }

         function main() {
             console.log("main start")
             canvas = document.getElementById("gl_canvas");
             gl = canvas.getContext("webgl");
             resizeCanvas();
         }

         requestAnimationFrame(render);

         window.addEventListener('resize', resizeCanvas);
         window.addEventListener('mousemove', movePointer);
         window.addEventListener('touchmove', movePointer);
         main();


        </script>


    </body>
</html>
