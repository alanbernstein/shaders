<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">
    <style type="text/css" >
    body {
        margin: 0;
        background-color: white;
    }

    a {
        text-decoration: none;
    }

    canvas {
        display: block;  /* prevents scrollbar */
        width: 100vw;
        height: 100vh;
        border: 1px solid black;
    }
    #container {
        position: relative;
    }
    #container canvas, .overlay {
        position: absolute;
    }

    .control-panel {
        background: #444;
        border: 3px solid #000;
        width: 33%;
        padding: 5px;
        border-radius: 10px;

        position: fixed;
        bottom: 10px;
        right: 10px;

        display: grid;
        grid-template-columns: 20% 25% 55%;
        grid-gap: 0px;
    }

    .control-panel>div {
        color: #fff;
        font-family: Arial, Helvetica, sans-serif;
        font-size: 2vw;
    }

    .label2 {
        color: lime;
    }

    .label3 {
        color: red;
    }

    .label4 {
        color: blue;
    }

    .header {
        grid-area: 1 / 1 / span 1 / span 3;
        height: 100px;
        width: 60%;
        margin-left: auto;
        margin-right: auto;
    }

    .footer-left {
        grid-area: 6 / 1 / span 1 / span 2;
    }

    .footer-right {
        grid-area: 6 / 3 / span 1 / span 1;
        text-align: right;
    }

    .box {
        margin-top: 15px;
        margin-bottom: 15px;
    }

    .hidden {
        display: none;
    }

    .overlay {
        z-index: 10;
        opacity: 90%;
    }

    </style>
    </head>
    <body>

        <!-- https://stackoverflow.com/questions/13870677/resize-viewport-canvas-according-to-browser-window-size -->
        <!-- https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html -->

        <div id="container">
            <canvas id="gl_canvas"></canvas>
            <div class="control-panel overlay" id="control-panel">
                <div class="header"><img class="overlay" src="images/generative-gradient-eq.png" height=100px></div>

                <div class="box"><label for="slider1" class="label1">color:</label></div>
                <div class="box"><span class="overlay label left-label label1" id="label1"></span></div>
                <div class="box"><input type="range" min="1" max="6" value="0" step="1" class="overlay slider" id="slider1"><br /></div>

                <div class="box"><label for="slider2" class="label2">order:</label></div>
                <div class="box"><span class="overlay label left-label label2" id="label2"></span></div>
                <div class="box"><input type="range" min="3.0" max="20.0" value="7.0" class="overlay slider" id="slider2"><br /></div>

                <div class="box"><label for="slider3" class="label3">speed:</label></div>
                <div class="box"><span class="overlay label left-label label3" id="label3"></span></div>
                <div class="box"><input type="range" min="-2.0" max="2.0" value="0.1" step="0.1" class="overlay slider" id="slider3"><br /></div>

                <div class="box"><label for="slider4" class="label4">width:</label></div>
                <div class="box"><span class="overlay label left-label label4" id="label4"></span></div>
                <div class="box"><input type="range" min="0.5" max="3.0" value="1.0" step="0.5" class="overlay slider" id="slider4"><br /></div>

                <div class="footer-left">SDF text</div>
                <div class="footer-right"><a href="index.html">←</a>&nbsp;<a id="toggler" onclick="toggleControls()">⇲</span></div>
            </div>
        </div>

        <script id="vertex-shader" type="glsl">
        attribute vec2 coord;
        void main() {
            gl_Position = vec4(coord, 0, 1);
        }
        </script>

        <script id="fragment-shader" type="glsl">
        #ifdef GL_FRAGMENT_PRECISION_HIGH
        precision highp float;
        #else
        precision mediump float;
        #endif

        float PI = 3.14159265359;
        uniform float millisecs;
        uniform float W;
        uniform float H;
        uniform float mx;
        uniform float my;
        uniform float v1;
        uniform float v2;
        uniform float v3;
        uniform float v4;

        float fmod(float x, float y) {
            return (x - y * floor(x / y));
        }

        float wrap(float x) {
            return abs(fmod(x+1.0,2.0)-1.0);
        }

        float line_segment(in vec2 p, in vec2 a, in vec2 b) {
            vec2 ba = b - a;
            vec2 pa = p - a;
            float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
            return length(pa - h * ba);
        }

        float arc(in vec2 p, in float a0, in float a1, in float r ) {
            float a = mod(atan(p.y, p.x), radians(360.));
        
            float ap = a - a0;
            if (ap < 0.)
                ap += radians(360.);
            float a1p = a1 - a0;
            if (a1p < 0.)
                a1p += radians(360.);
        
            // is a outside [a0, a1]?
            // https://math.stackexchange.com/questions/1044905/simple-angle-between-two-angles-of-circle
            if (ap >= a1p) {
                    // clamp angle to [a0, a1] by finding the closer one of the two
                    // https://gamedev.stackexchange.com/questions/4467/comparing-angles-and-working-out-the-difference
                    float da0 = abs(abs(a0 - a) - radians(180.)); 
                    float da1 = abs(abs(a1 - a) - radians(180.)); 
                    if (da0 > da1)
                        a = a0;
                    else
                        a = a1;
            }
        
            vec2 q = vec2(r * cos(a), r * sin(a));
            return length(q - p); 
        }
        
        float hue2rgb(float f1, float f2, float hue) {
            if (hue < 0.0)
                hue += 1.0;
            else if (hue > 1.0)
                hue -= 1.0;
            float res;
            if ((6.0 * hue) < 1.0)
                res = f1 + (f2 - f1) * 6.0 * hue;
            else if ((2.0 * hue) < 1.0)
                res = f2;
            else if ((3.0 * hue) < 2.0)
                res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;
            else
                res = f1;
            return res;
        }
        
        vec3 hsl2rgb(vec3 hsl) {
            vec3 rgb;
            
            if (hsl.y == 0.0) {
                rgb = vec3(hsl.z); // Luminance
            } else {
                float f2;
                
                if (hsl.z < 0.5)
                    f2 = hsl.z * (1.0 + hsl.y);
                else
                    f2 = hsl.z + hsl.y - hsl.y * hsl.z;
                    
                float f1 = 2.0 * hsl.z - f2;
                
                rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));
                rgb.g = hue2rgb(f1, f2, hsl.x);
                rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));
            }   
            return rgb;
        }
        
        vec3 hsl2rgb(float h, float s, float l) {
            // https://github.com/Jam3/glsl-hsl2rgb/blob/master/index.glsl
            return hsl2rgb(vec3(h, s, l));
        }

        float sdf_text(float t, vec2 pos) {
            // manual text example
            // TODO: array of structs instead
            float d = 1000.0;
            // H
            d = min(d, line_segment(pos, vec2(0, 0), vec2(0, 2)));
            d = min(d, line_segment(pos, vec2(1, 0), vec2(1, 2)));
            d = min(d, line_segment(pos, vec2(0, 1), vec2(1, 1)));
            // I
            d = min(d, line_segment(pos, vec2(2, 0), vec2(2, 2)));
            // G
            d = min(d, line_segment(pos, vec2(3, .5), vec2(3, 1.5)));
            d = min(d, line_segment(pos, vec2(4, .5), vec2(4, 1)));
            d = min(d, line_segment(pos, vec2(3.5, 1), vec2(4, 1)));
            d = min(d, arc(pos-vec2(3.5, 1.5), 0.0, PI, 0.5));
            d = min(d, arc(pos-vec2(3.5, .5), PI, 2.0*PI, 0.5));
            // H
            d = min(d, line_segment(pos, vec2(5, 0), vec2(5, 2)));
            d = min(d, line_segment(pos, vec2(6, 0), vec2(6, 2)));
            d = min(d, line_segment(pos, vec2(5, 1), vec2(6, 1)));
            // L
            d = min(d, line_segment(pos, vec2(7, 0), vec2(7, 2)));
            d = min(d, line_segment(pos, vec2(7, 0), vec2(8, 0)));
            // A
            d = min(d, line_segment(pos, vec2(9, 0), vec2(9, 1.5)));
            d = min(d, line_segment(pos, vec2(9, 1), vec2(10, 1)));
            d = min(d, line_segment(pos, vec2(10, 1.5), vec2(10, 0)));
            d = min(d, arc(pos-vec2(9.5, 1.5), 0.0, PI, 0.5));
            // N
            d = min(d, line_segment(pos, vec2(11, 0), vec2(11, 1.5)));
            d = min(d, line_segment(pos, vec2(12, 0), vec2(12, 1.5)));
            d = min(d, arc(pos-vec2(11.5, 1.5), 0.0, PI, 0.5));
            // D
            d = min(d, line_segment(pos, vec2(13, 0), vec2(13, 2)));
            d = min(d, line_segment(pos, vec2(13, 0), vec2(13.5, 0)));
            d = min(d, line_segment(pos, vec2(13, 2), vec2(13.5, 2)));
            d = min(d, line_segment(pos, vec2(14, .5), vec2(14, 1.5)));
            d = min(d, arc(pos-vec2(13.5, 1.5), 0.0, 0.5*PI, 0.5));
            d = min(d, arc(pos-vec2(13.5, 0.5), 1.5*PI, 2.0*PI, 0.5));

            return d;
        }

        vec4 color1(float t, float d, float order, float speed, float width) {
            // continuous gradient color
            /*
            z = d;                    // distance from SDF scene
            z = z/width               // size of colorbands
            z = z - t*speed           // bands emanate out (or in) from letterforms
            z = wrap(z)               // bidirectional wrap in [0, 1] - ugly, dont do it
            z = floor(order*z)/order  // quantize to get bands
            z = fmod(z, 1.0)          // unidirectional wrap in [0, 1]
            */
            float zz = floor(order*(d/width-t*speed))/order;
            vec3 rgb = hsl2rgb(fmod(zz, 1.0), 1.0, 0.5);
            return vec4(rgb, 1.0);
        }

        vec4 color2(float d, float width) {
            // simple color
            d = d/width;
            float z = wrap(10.0 * d / 1.0);  // z -> sawtooth in [0, 1]
            return vec4(1.0-z, 1.0-z, z, 1);
        }

        vec4 color3(float d, float width) {
            // Inigo Quilez brown/blue banded color
            vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);
            float dd = d/width/10.0;
            col *= 1.0 - exp(-2.0*abs(dd));
            col *= 0.8 + 0.2*cos(140.0*dd);
            col = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(dd)) );
            return vec4(col,1.0);
        }

        vec4 color4(float t, float d, float speed, float width) {
            // 70s retro constant-N palette
            /*
            const vec3 cmap[6] = vec3[6](
                vec3(63, 138, 140),
                vec3(12, 86, 121),
                vec3(11, 8, 53),
                vec3(229, 52, 11),
                vec3(242, 138, 15),
                vec3(255, 231, 189)
            );
            vec3 rgb = cmap[zz];
            */
            
            float order = 6.0;

            float zz = fmod(floor(order*(d/width-t*speed))/order, 8.0);
            vec3 rgb;
            if (zz <= 6.0) {
                rgb = vec3(63, 138, 140);                
            }
            if (zz <= 5.0) {
                rgb = vec3(12, 86, 121);
            }
            if (zz <= 4.0) {
                rgb = vec3(11, 8, 53);
            }
            if (zz <= 3.0) {
                rgb = vec3(229, 52, 11);
            }
            if (zz <= 2.0) {
                rgb = vec3(242, 138, 15);
            }
            if (zz <= 1.0) {
                rgb = vec3(255, 231, 189);
                // rgb = vec3(86, 59, 15);
            }
            return vec4(rgb/255.0, 1.0);
        }

        struct gradient {
            vec3 a;
            vec3 b;
            vec3 c;
            vec3 d;
        };
        gradient g1 = gradient(vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.33,0.67));  // rainbow
        gradient g2 = gradient(vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.10,0.20));
        gradient g3 = gradient(vec3(0.537, 0.582, 0.300), vec3(-0.559, -0.497, 0.336), vec3(4.920, 3.839, 6.292), vec3(0.514, -0.022, 0.939)); // 6-color 70s palette


        //gradient g3 = gradient(vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.3,0.20,0.20));
        //gradient g4 = gradient(vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,0.5), vec3(0.8,0.90,0.30));
        //gradient g5 = gradient(vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,0.7,0.4), vec3(0.0,0.15,0.20));
        //gradient g6 = gradient(vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(2.0,1.0,0.0), vec3(0.5,0.20,0.25));
        //gradient g7 = gradient(vec3(0.8,0.5,0.4), vec3(0.2,0.4,0.2), vec3(2.0,1.0,1.0), vec3(0.0,0.25,0.25));
        //gradient g8 = gradient(vec3(0.821, 0.328, 0.242), vec3(0.659, 0.481, 0.896), vec3(0.612, 0.340, 0.296), vec3(2.820, 3.026, -0.273));

        vec4 gengrad(float t, float d, gradient g, float order, float speed, float width) {
            // Inigo Quilez generative gradient palette
            // https://www.shadertoy.com/view/ll2GD3
            // http://dev.thi.ng/gradients/

            // compute colors
            float z = d/width - speed*t;
            vec3 col = clamp(g.a + g.b*cos( 6.28318*(g.c*z+g.d) ), 0.0, 1.0);
            col = ceil(col*order) / order;

            // band
            //float f = fract(1.0*7.0);
            // borders
            //col *= smoothstep(0.49, 0.47, 0.5);
            // shadowing
            //col *= 0.5 + 0.5*sqrt(4.0*f*(1.0-f));

            return vec4( col, 1.0 );
        }

        void main() {
            vec2 res = vec2(W, H);
            vec2 pos = (gl_FragCoord.xy - res.xy * .5) / min(res.x, res.y);
            float zoom = 20.0;
            pos *= zoom;
            pos += vec2(7, .7);
            float t = 1.0 * millisecs / 1000.0;

            float color = v1;
            float order = v2;
            float speed = v3;
            float width = v4;

            float d = sdf_text(t, pos);
            if(color == 1.0) { gl_FragColor = color1(t, d, order, speed, width); }
            if(color == 2.0) { gl_FragColor = color2(d, width); }
            if(color == 3.0) { gl_FragColor = color3(d, width); }
            if(color == 4.0) { gl_FragColor = color4(t, d, speed, width); }
            if(color == 5.0) { gl_FragColor = gengrad(t, d, g1, order, speed, width); }
            if(color == 6.0) { gl_FragColor = gengrad(t, d, g2, order, speed, width); }
        }

        </script>


        <script type="text/javascript">

        canvas = document.getElementById("gl_canvas");
        gl = canvas.getContext("webgl");
        gl.canvas.width  = window.innerWidth;
        gl.canvas.height = window.innerHeight;

        // webgl boilerplate
        gl.viewport(0,0,canvas.width, canvas.height);
        const vertShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertShader, document.getElementById('vertex-shader').innerText);
        gl.compileShader(vertShader);
        const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragShader, document.getElementById('fragment-shader').innerText);
        gl.compileShader(fragShader);
        if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(fragShader));
        }
        const prog = gl.createProgram();
        gl.attachShader(prog, vertShader);
        gl.attachShader(prog, fragShader);
        gl.linkProgram(prog);
        gl.useProgram(prog);
        const vertBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,1,  -1,-1,  1,-1, 1,1]), gl.STATIC_DRAW);
        const coordPtr = gl.getAttribLocation(prog, 'coord');
        gl.vertexAttribPointer(coordPtr, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(coordPtr);
        gl.clearColor(1,0,0,1);

         // setup uniform variables
        const millisecsPtr = gl.getUniformLocation(prog, 'millisecs');
        const canvasWidthPtr = gl.getUniformLocation(prog, 'W');
        const canvasHeightPtr = gl.getUniformLocation(prog, 'H');
        const mouseXPtr = gl.getUniformLocation(prog, 'mx');
        const mouseYPtr = gl.getUniformLocation(prog, 'my');
        const v1Ptr = gl.getUniformLocation(prog, 'v1');
        const v2Ptr = gl.getUniformLocation(prog, 'v2');
        const v3Ptr = gl.getUniformLocation(prog, 'v3');
        const v4Ptr = gl.getUniformLocation(prog, 'v4');
        const start = new Date().getTime();

        mouseX = window.innerWidth/2
        mouseY = window.innerHeight/2

        function render() {
            console.log("render start");

            var w = canvas.clientWidth;
            var h = canvas.clientHeight;

            gl.viewport(0, 0, w, h);

            v1_labels = {
                1: "primary",
                2: "simple",
                3: "IQ",
                4: "70s",
                5: "gengrad1",
                6: "6",
            }
            // shader stuff
            var v1 = document.getElementById("slider1").value
            document.getElementById("label1").innerHTML = v1_labels[v1];
            var v2 = document.getElementById("slider2").value
            document.getElementById("label2").innerHTML = v2;
            var v3 = document.getElementById("slider3").value
            document.getElementById("label3").innerHTML = v3;
            var v4 = document.getElementById("slider4").value
            document.getElementById("label4").innerHTML = v4;

            gl.uniform1f(millisecsPtr, (new Date().getTime())-start);
            gl.uniform1f(v1Ptr, v1);
            gl.uniform1f(v2Ptr, v2);
            gl.uniform1f(v3Ptr, v3);
            gl.uniform1f(v4Ptr, v4);
            gl.uniform1f(canvasWidthPtr, w);
            gl.uniform1f(canvasHeightPtr, h);
            gl.uniform1f(mouseXPtr, mouseX);
            gl.uniform1f(mouseYPtr, mouseY);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
            requestAnimationFrame(render);
        };

        function resizeCanvas() {

            var width = canvas.clientWidth;
            var height = canvas.clientHeight;
            console.log("resizeCanvas start "  +width+" "+height)
            if (canvas.width != width ||
                canvas.height != height) {
                canvas.width = width;
                canvas.height = height;

                // in this case just render when the window is resized.
                render();
            }
        }

        function movePointer(e) {
            mouseX = e.clientX
            mouseY = e.clientY
        }

        function toggleControls() {
            toggler = document.getElementById("toggler");
            boxes = document.querySelectorAll(".box, .header");
            stateChar = toggler.innerHTML;
            if(stateChar === "⇲") { // hide
                toggler.innerHTML = "⇱";
                boxes.forEach((box) => {box.classList.add("hidden")})
            } else if(stateChar == "⇱") { // show
                toggler.innerHTML = "⇲";
                boxes.forEach((box) => {box.classList.remove("hidden")})
            }
        }

        function main() {
            console.log("main start")
            canvas = document.getElementById("gl_canvas");
            gl = canvas.getContext("webgl");
            resizeCanvas();
        }

        requestAnimationFrame(render);

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('mousemove', movePointer);
        window.addEventListener('touchmove', movePointer);
        main();


        </script>


    </body>
</html>
