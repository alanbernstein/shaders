<!DOCTYPE html>
<html>
    <head>
    <style type="text/css" >
    body {
        margin: 0;
        background-color: white;
    }
    canvas {
        display: block;  /* prevents scrollbar */
        width: 100vw;
        height: 100vh;
     }
     #container {
         position: relative;
     }
     #container canvas, .overlay {
         position: absolute;
     }
     canvas {
         border: 1px solid black;
     }

     .overlay {
         z-index: 10;
         opacity: 90%;
     }

    </style>
    </head>
    <body>


        <!-- https://stackoverflow.com/questions/13870677/resize-viewport-canvas-according-to-browser-window-size -->
        <!-- https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html -->

        <div id="container">
            <canvas id="gl_canvas"></canvas>
            <div class="slider-container overlay">
                <label for="slider1" class="label1">v1:</label>
                <span class="overlay label left-label label1" id="label1"></span>
                <input type="range" min="3.0" max="10.0" value="7.0" class="overlay slider" id="slider1"><br />

            </div>

        <script id="vertex-shader" type="glsl">
         attribute vec2 coord;
         void main() {
             gl_Position = vec4(coord, 0, 1);
         }
        </script>

        <script id="fragment-shader" type="glsl">
         #ifdef GL_FRAGMENT_PRECISION_HIGH
	       precision highp float;
         #else
           precision mediump float;
         #endif

         float PI = 3.14159265359;
         uniform float millisecs;
         uniform float W;
         uniform float H;
         uniform float mx;
         uniform float my;
         uniform float v1;

         float fmod(float x, float y) {
             return (x - y * floor(x / y));
         }

         float wrap(float x) {
             return abs(fmod(x+1.0,2.0)-1.0);
         }

         float line_segment(in vec2 p, in vec2 a, in vec2 b) {
            vec2 ba = b - a;
            vec2 pa = p - a;
            float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
            return length(pa - h * ba);
        }

        float arc(in vec2 p, in float a0, in float a1, in float r ) {
            float a = mod(atan(p.y, p.x), radians(360.));
        
            float ap = a - a0;
            if (ap < 0.)
                ap += radians(360.);
            float a1p = a1 - a0;
            if (a1p < 0.)
                a1p += radians(360.);
        
            // is a outside [a0, a1]?
            // https://math.stackexchange.com/questions/1044905/simple-angle-between-two-angles-of-circle
            if (ap >= a1p) {
                    // clamp angle to [a0, a1] by finding the closer one of the two
                    // https://gamedev.stackexchange.com/questions/4467/comparing-angles-and-working-out-the-difference
                    float da0 = abs(abs(a0 - a) - radians(180.)); 
                    float da1 = abs(abs(a1 - a) - radians(180.)); 
                    if (da0 > da1)
                        a = a0;
                    else
                        a = a1;
            }
        
            vec2 q = vec2(r * cos(a), r * sin(a));
            return length(q - p); 
        }
        
        float hue2rgb(float f1, float f2, float hue) {
            if (hue < 0.0)
                hue += 1.0;
            else if (hue > 1.0)
                hue -= 1.0;
            float res;
            if ((6.0 * hue) < 1.0)
                res = f1 + (f2 - f1) * 6.0 * hue;
            else if ((2.0 * hue) < 1.0)
                res = f2;
            else if ((3.0 * hue) < 2.0)
                res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;
            else
                res = f1;
            return res;
        }
        
        vec3 hsl2rgb(vec3 hsl) {
            vec3 rgb;
            
            if (hsl.y == 0.0) {
                rgb = vec3(hsl.z); // Luminance
            } else {
                float f2;
                
                if (hsl.z < 0.5)
                    f2 = hsl.z * (1.0 + hsl.y);
                else
                    f2 = hsl.z + hsl.y - hsl.y * hsl.z;
                    
                float f1 = 2.0 * hsl.z - f2;
                
                rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));
                rgb.g = hue2rgb(f1, f2, hsl.x);
                rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));
            }   
            return rgb;
        }
        
        vec3 hsl2rgb(float h, float s, float l) {
            return hsl2rgb(vec3(h, s, l));
        }

        vec4 scene(float t, vec2 pos) {
            // manual text example
            // TODO: array of structs instead
            float d = 100.0;
            // H
            d = min(d, line_segment(pos, vec2(0, 0), vec2(0, 2)));
            d = min(d, line_segment(pos, vec2(1, 0), vec2(1, 2)));
            d = min(d, line_segment(pos, vec2(0, 1), vec2(1, 1)));
            // I
            d = min(d, line_segment(pos, vec2(2, 0), vec2(2, 2)));
            // G
            d = min(d, line_segment(pos, vec2(3, .5), vec2(3, 1.5)));
            d = min(d, line_segment(pos, vec2(4, .5), vec2(4, 1)));
            d = min(d, line_segment(pos, vec2(3.5, 1), vec2(4, 1)));
            d = min(d, arc(pos-vec2(3.5, 1.5), 0.0, PI, 0.5));
            d = min(d, arc(pos-vec2(3.5, .5), PI, 2.0*PI, 0.5));
            // H
            d = min(d, line_segment(pos, vec2(5, 0), vec2(5, 2)));
            d = min(d, line_segment(pos, vec2(6, 0), vec2(6, 2)));
            d = min(d, line_segment(pos, vec2(5, 1), vec2(6, 1)));
            // L
            d = min(d, line_segment(pos, vec2(7, 0), vec2(7, 2)));
            d = min(d, line_segment(pos, vec2(7, 0), vec2(8, 0)));
            // A
            d = min(d, line_segment(pos, vec2(9, 0), vec2(9, 1.5)));
            d = min(d, line_segment(pos, vec2(9, 1), vec2(10, 1)));
            d = min(d, line_segment(pos, vec2(10, 1.5), vec2(10, 0)));
            d = min(d, arc(pos-vec2(9.5, 1.5), 0.0, PI, 0.5));
            // N
            d = min(d, line_segment(pos, vec2(11, 0), vec2(11, 1.5)));
            d = min(d, line_segment(pos, vec2(12, 0), vec2(12, 1.5)));
            d = min(d, arc(pos-vec2(11.5, 1.5), 0.0, PI, 0.5));
            // D
            d = min(d, line_segment(pos, vec2(13, 0), vec2(13, 2)));
            d = min(d, line_segment(pos, vec2(13, 0), vec2(13.5, 0)));
            d = min(d, line_segment(pos, vec2(13, 2), vec2(13.5, 2)));
            d = min(d, line_segment(pos, vec2(14, .5), vec2(14, 1.5)));
            d = min(d, arc(pos-vec2(13.5, 1.5), 0.0, 0.5*PI, 0.5));
            d = min(d, arc(pos-vec2(13.5, 0.5), 1.5*PI, 2.0*PI, 0.5));

            float order = v1;
            float zz = floor(order*wrap(d-t*0.1))/order;
            vec3 rgb = hsl2rgb(zz, 1.0, 0.5);
            return vec4(rgb, 1.0);

            //float z = wrap(5.0 * d / 1.0);  // z in [0, 1]
            //return vec4(1.0-z, 1.0-z, z, 1);


            //vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);
            //col *= 1.0 - exp(-2.0*abs(d));
            //col *= 0.8 + 0.2*cos(140.0*d);
            //col = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );
            //return vec4(col,1.0);
        }

        void main() {
            vec2 iResolution = vec2(W, H);
            vec2 pos = (gl_FragCoord.xy - iResolution.xy * .5) / iResolution.y;
            float zoom = 10.0;
            pos *= zoom;
            pos += vec2(7, .7);
            float t = 1.0 * millisecs / 1000.0;

            gl_FragColor = scene(t, pos);
        
         }

        </script>


        <script type="text/javascript">

         canvas = document.getElementById("gl_canvas");
         gl = canvas.getContext("webgl");
         gl.canvas.width  = window.innerWidth;
         gl.canvas.height = window.innerHeight;

         // webgl boilerplate
         gl.viewport(0,0,canvas.width, canvas.height);
         const vertShader = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader, document.getElementById('vertex-shader').innerText);
         gl.compileShader(vertShader);
         const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader, document.getElementById('fragment-shader').innerText);
         gl.compileShader(fragShader);
         if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
             console.error(gl.getShaderInfoLog(fragShader));
         }
         const prog = gl.createProgram();
         gl.attachShader(prog, vertShader);
         gl.attachShader(prog, fragShader);
         gl.linkProgram(prog);
         gl.useProgram(prog);
         const vertBuf = gl.createBuffer();
         gl.bindBuffer(gl.ARRAY_BUFFER, vertBuf);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,1,  -1,-1,  1,-1, 1,1]), gl.STATIC_DRAW);
         const coordPtr = gl.getAttribLocation(prog, 'coord');
         gl.vertexAttribPointer(coordPtr, 2, gl.FLOAT, false, 0, 0);
         gl.enableVertexAttribArray(coordPtr);
         gl.clearColor(1,0,0,1);

         // setup uniform variables
         const millisecsPtr = gl.getUniformLocation(prog, 'millisecs');
         const canvasWidthPtr = gl.getUniformLocation(prog, 'W');
         const canvasHeightPtr = gl.getUniformLocation(prog, 'H');
         const mouseXPtr = gl.getUniformLocation(prog, 'mx');
         const mouseYPtr = gl.getUniformLocation(prog, 'my');
         const v1Ptr = gl.getUniformLocation(prog, 'v1');
         const start = new Date().getTime();

         mouseX = window.innerWidth/2
         mouseY = window.innerHeight/2

         function render() {
             console.log("render start");

             var w = canvas.clientWidth;
             var h = canvas.clientHeight;

             gl.viewport(0, 0, w, h);

             // shader stuff
             var v1 = document.getElementById("slider1").value
             document.getElementById("label1").innerHTML = v1;

             gl.uniform1f(millisecsPtr, (new Date().getTime())-start);
             gl.uniform1f(v1Ptr, v1);
             gl.uniform1f(canvasWidthPtr, w);
             gl.uniform1f(canvasHeightPtr, h);
             gl.uniform1f(mouseXPtr, mouseX);
             gl.uniform1f(mouseYPtr, mouseY);
             gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
             requestAnimationFrame(render);
         };

         function resizeCanvas() {

             var width = canvas.clientWidth;
             var height = canvas.clientHeight;
             console.log("resizeCanvas start "  +width+" "+height)
             if (canvas.width != width ||
                 canvas.height != height) {
                 canvas.width = width;
                 canvas.height = height;

                 // in this case just render when the window is resized.
                 render();
             }
         }

         function movePointer(e) {
             mouseX = e.clientX
             mouseY = e.clientY
         }

         function main() {
             console.log("main start")
             canvas = document.getElementById("gl_canvas");
             gl = canvas.getContext("webgl");
             resizeCanvas();
         }

         requestAnimationFrame(render);

         window.addEventListener('resize', resizeCanvas);
         window.addEventListener('mousemove', movePointer);
         window.addEventListener('touchmove', movePointer);
         main();


        </script>


    </body>
</html>
